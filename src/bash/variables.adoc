= Bash: Variables

== Types

Unix shells don't have formal data types, like high-level programming languages. Instead, every variable value is treated as a string by default.

But there are behaviors that interpret values into other types. For examples, variables are treated as integers when used in arithmetic contexts.

Furthermore, community conventions have emerged for simulating other types; for example, the string values "true" and "false" are commonly used to represent boolean values.

== Variable declaration

You don't need to declare variables. You just assign a value to a reference, and that is enough to create the variable.

[source,bash]
----
str="Hello, World!"
echo "${str}"
----

Unlike most programming languages, there MUST NOT be spaces around the assignment operator (`=`).

== Read-only variables

Variables may be turned into constants, which means their value cannot be changed after being set the first time.

[source,bash]
----
readonly str="Hello, World!"
echo "${str}"
----

== Local variables

Bash supports `local` variables, which are variables scoped to the function they are declared in.

[source,bash]
----
hello="hello"

function hello {
  local hello="world"
  echo "${hello}" # → "world" (the local variable is distinct from the global one with the same name)
}

echo "${hello}" # → "hello" (unchanged)
----

Local variables may be declared, then subsequently assigned.

[source,bash]
----
local hello
hello="world"
----

== Variable substitution

In Bash, variable substitution (also known as variable expansion) is done using the dollar sign (`$`) followed by the variable name. For example, to use a variable named `var`, you would write `$var`.

An alternative syntax is to wrap the variable name in curly braces (`{}`). Thus, the two available syntax for variable substitution are:

* `$var`
* `${var}`

Generally, both syntaxes behave identically. But there are subtle differences that make `${var}` more robust and flexible. For example, because the brackets clearly delimit the variable name, it is easier to append literal characters immediately after the variable expansion.

[source,bash]
----
var="foo"

echo "$varbar"     # Looks for a variable named 'varbar' (likely undefined).
echo "${var}bar"   # Correctly expands to 'foobar'.
----

The bracketed syntax also supports extended syntax for querying and manipulating the values of variables.

[source,bash]
----
var="Hello, World!"

# Returns the length of the variable.
${#var}

# Returns the first character of the variable.
${var:0:1}

# Or:
${var%%"${var#?}"}

# Remove characters from a string:
${var:2}    # Remove the first two characters.
${var#*, }  # Remove everything up to the first comma and space.
${var##*, } # Remove everything up to the last comma and space.
${var%,*}   # Remove everything after the last comma.
${var%%,*}  # Remove everything after the first comma.

# Replacing characters:
var="0050"
${var[@]#0} # Remove the first leading zero.
${var/a/b}  # Replace "a" with "b".
${var//a/b} # Replace all "a" with "b".

# Set a default value, which is used if `var` is unset.
${var:-default}
----

== Built-in variables

Other built-in variables include:

[source,bash]
----
$0              # Name of shell or shell script.
$1, $2, $3, ... # Positional parameters (from command-line input arguments).
$#              # Number of positional parameters.
$?              # Most recent foreground pipeline exit status.
$-              # Current options set for the shell.
$$              # PID of the current shell (not sub-shell).
$!              # The PID of the most recent background command.
$_              # Last argument of the previously executed command,
                #   or the path of the bash script.
----

They special variables MAY also be written using the bracketed syntax, eg. `${0}`, but tend not to be.

== Return values

`$?` is a special variable that returns the value of the last-executed command.

[source,bash]
----
cd /dada &> /dev/null
echo rv: $?

cd $(pwd) &> /dev/null
echo rv: $?
----

== Command substitution

Use command substitution to capture the output of a command into a variable.

[source,bash]
----
# Modern syntax.
var=$(command)

# Old syntax - but it still works.
var=`command`

----

Be careful about assigning the result of commands to local variables. Consider the following example. It looks to be correct, but `$?` actually contains the exit code of `local`, not of `my_func`.

[source,bash]
----
test_fn() {
  local my_var="$(my_func)"
  [[ $? -eq 0 ]] || return

  # ...
}
----

The solution is to declare the local variable, and then assign its value (using command substitution) separately.

[source,bash]
----
test_fn() {
  local my_var
  my_var="$(my_func)" || return

  # ...
}
----

== Multi-line strings

String values can contain newline characters, if quoted.

[source,bash]
----
dbuser="admin"
dbpass="secret"

my_cnf="
[mysql]
user=${dbuser}
password=${dbpass}
host=localhost

[mysqladmin]
user=${dbuser}
password=${dbpass}
host=localhost

[mysqldump]
user=${dbuser}
password=${dbpass}
host=localhost
"

echo "${my_cnf}" > /home/vagrant/.my.cnf
----

Another way to do this:

[source,bash]
----
dbuser="admin"
dbpass="secret"

read -r -d '' my_cnf <<EOF
[mysql]
user=${dbuser}
password=${dbpswd}
host=localhost

[mysqladmin]
user=${dbuser}
password=${dbpswd}
host=localhost

[mysqldump]
user=${dbuser}
password=${dbpswd}
host=localhost
EOF

echo "${my_cnf}" > /home/vagrant/.my.cnf
----

For this particular use case, where the variable is just a temporary store for a value that will be piped into a file, the variable can be omitted and the value just piped directly to the file.

[source,bash]
----
dbuser="admin"
dbpass="secret"

echo "
[mysql]
user=${dbuser}
password=${dbpswd}
host=localhost

[mysqladmin]
user=${dbuser}
password=${dbpswd}
host=localhost

[mysqldump]
user=${dbuser}
password=${dbpswd}
host=localhost
" | tee /home/vagrant/.my.cnf
----

An alternative, common practice is to use `cat` and a heredoc to pipe values directly to files.

[source,bash]
----
dbuser="admin"
dbpass="secret"

cat > /home/vagrant/.my.cnf <<EOF
[mysql]
user=${dbuser}
password=${dbpass}
host=localhost

[mysqladmin]
user=${dbuser}
password=${dbpass}
host=localhost

[mysqldump]
user=${dbuser}
password=${dbpass}
host=localhost
EOF
----

`tee` can do the same thing.

[source,bash]
----
dbuser="admin"
dbpass="secret"

tee /home/vagrant/.my.cnf <<EOF
[mysql]
user=${dbuser}
password=${dbpswd}
host=localhost

[mysqladmin]
user=${dbuser}
password=${dbpswd}
host=localhost

[mysqldump]
user=${dbuser}
password=${dbpswd}
host=localhost
EOF
----

== Array variables

Arrays hold multiple values, each accessible by an index.

[source,bash]
----
arr=("item1" "item2" "item3")

${arr[0]}  # Access the first element.
${arr[@]}  # Access all elements.
${#arr[@]} # Get the length of the array.
----

== Reading user input

You can prompt for user input and capture that in a variable, using `read`:

[source,bash]
----
echo Please, enter your name
read user_name

echo "Hi ${user_name}!"
----

You can get multiple values with `read`, too:

[source,bash]
----
echo Please, enter your first and last name.
read first_name last_name

echo "Hi! ${first_name} ${last_name}!"
----

[IMPORTANT]
======
Always validate user input.
======
