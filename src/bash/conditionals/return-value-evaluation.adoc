= Bash: Evaluating return values

A common use case for conditionals is to check the result of some command, and take action based on whether it succeeded or failed.

[source,bash]
----
if command; then
  # Command succeeded
else
  # Command failed
fi
----

.Example
[source,bash]
----
if ! mv "${file_list}" "${dest_dir}/" ; then
  echo "Unable to move ${file_list} to ${dest_dir}" >&2
  exit "${E_BAD_MOVE}"
fi
----

For un-piped commands, you can instead use `$?` to check the return value of the command, like this:

[source,bash]
----
mv "${file_list}" "${dest_dir}/"
if [[ "$?" -ne "0" ]]; then
  echo "Unable to move ${file_list} to ${dest_dir}" >&2
  exit "${E_BAD_MOVE}"
fi
----

For piped commands, Bash has the `PIPESTATUS` variable that allows checking of the return code from all parts of a pipe. If it's only necessary to check the success or failure of the whole pipe, then the following is acceptable:

[source,bash]
----
tar -cf - ./* | ( cd "${dir}" && tar -xf - )
if [[ "${PIPESTATUS[0]}" -ne 0 || "${PIPESTATUS[1]}" -ne 0 ]]; then
  echo "Unable to tar files to ${dir}" >&2
fi
----

However, as `PIPESTATUS` will be overwritten as soon as you do any other command, if you need to act differently on errors based on where it happened in the pipe, you'll need to assign `PIPESTATUS` to another variable immediately after running the command. Don't forget that `[` itself is a command, and it will therefore wipe out `PIPESTATUS`.)

[source,bash]
----
tar -cf - ./* | ( cd "${DIR}" && tar -xf - )
return_codes=(${PIPESTATUS[*]})

if [[ "${return_codes[0]}" -ne 0 ]]; then
  do_something
fi
if [[ "${return_codes[1]}" -ne 0 ]]; then
  do_something_else
fi
----
