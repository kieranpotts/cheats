= GPG (GNU Privacy Guard)

https://www.ietf.org/rfc/rfc4880.txt[OpenPGP] is a standard for cryptographic privacy and authentication. The standard contains specifications on algorithms, encodings, etc. for encrypting and signing data, and other use cases for cryptography. OpenPGP specifies a decentralized trust model, in which pairs of public and private keys are managed by the users of those keys themselves, rather than by a central authority.

https://www.gnupg.org/[GPG] is a free, open source implementation of the OpenPGP standard. It is a command line tool, widely available on all major operating systems. It is widely trusted because it is open source, follows established cryptographic standards, and has been thoroughly audited by security experts over many years.

== How GPG works

GPG implements key-based asymmetric cryptography. You using the `gpg` utility to create two mathematically related keys:

* A *public key*, which you share openly, and which is used by others to encrypt messages that they send to you, or to verify your signatures.

* A *private key*, which you keep secret, and which you use to decrypt messages that are sent to you, or which you use to create digital signatures uses for signing your own messages.

Thus, when someone wants to send you a secure message – whether by email or any other insecure channel – they use your public key to encrypt it. Only you can decrypt it with your private key.

You can also "sign" your own files and messages. This is done to prove the authenticity of those files and messages – to prove that they really came from you and haven't been tampered with by others. This works the other way around: you sign a message with your private key, and recipients of the message use your public key to verify the message's signature.

When you sign a message, you're adding a cryptographically-strong proof that you – or someone in possession of your private key – wrote the message, and that the message was not tampered with. The steps to add a signature are:

1. You calculate a hash (or checksum) of the message, using a hashing function such as SHA-256. Hashing functions are one-way operations that generate a unique set of bytes from a message.
2. You use your private key to sign the calculated hash, using algorithms like RSA.
3. You send the signature with the original clear-text (unencrypted) message.

It is possible to use RSA to both sign and encrypt a message. This is called "authenticated encryption".

== Use cases

GPG can be used to encrypt, decrypt, sign, and verify any arbitrary data. Common use cases include:

* Secure email
* File encryption
* Software distribution
* Password management
* Document authentication

=== Package managers

For example, when adding packages from third-party repositories in Linux, GPG keys tend to be used to verify the authenticity of the downloaded packages. It works like this:

1. Third-party package providers sign their packages, adding a signature in the package metadata using their private GPG key.
2. The third-party repository publishes its public GPG key at a publicly-accessible web address.
3. You download and add the public key to your system's trusted keyring.
4. When you install packages from the third-party repository, your package manager verifies the authenticity of the downloaded packages by verifying the packages' signatures with the public key. Only valid packages are installed.

In the following code example, Docker's public GPG key is downloaded and added to APT's keyring. Docker's own package repository is then added as a source for APT to install packages from, and APT is configured to use Docker's public key to verify packages downloaded from that repository.

----
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor --yes --output /etc/apt/keyrings/docker.gpg

echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
----

Trusted keys can be viewed in these directories:

* `/usr/share/keyrings/`
* `/etc/apt/trusted.gpg.d/`

=== Signing Git commits

Another use case is the signing of Git commits.

To set this up, first check if you already have a GPG key pair:

----
$ gpg --list-secret-keys --keyid-format=long
----

The key ID is the bit on the `sec` line after the first `/`:

----
sec   <key-type>/<key-id> <creation-date>
----

In the following example, the key ID is `3AA5C34371567BD2`:

----
sec   rsa4096/3AA5C34371567BD2 2025-09-15 [SC]
      C142F66F50AC8C832C8CF7553AA5C34371567BD2
----

If you don't already have a GPG key, create one with the following command.

----
$ gpg --full-generate-key
----

At the prompts, choose RSA, 4096 bits, and set an expiration date. For your uid, use the same email address you use to create Git commits that will be pushed to GitHub/GitLab. If you use a private email aliases provided by GitHub, use that.

Optionally, you can set a passphrase to protect your private key. If you set a passphrase, you'll need to enter it each time you use the key (though the GPG agent can cache it for a while). You may also need to add the following line to your `~/.bashrc` or `~/.zshrc` file. This tells GPG to use the current terminal for passphrase prompts.

----
export GPG_TTY=$(tty)
----

Before adding the GPG key to your Git config, check that you've configured your key correctly. You can do this by using it to sign an arbitrary piece of text:

----
echo "test" | gpg --clearsign
----

You should be prompted for your GPG key's passphrase (if set) and you will see the signed text output.

Now you can add your key ID to your Git config:

----
$ git config --global user.signingkey <key-id>
----

You can now sign commits and tags on a case-by-case basis:

----
git commit -S -m "Your commit message"
git tag -s v1.0 -m "Version 1.0"
----

Once you've verified this works as expected, you can make this the default behavior for all commits:

----
$ git config --global commit.gpgsign true
----

Finally, before you push any signed commits, you need to export your public key, and copy the output into your GitHub/GitLab account (in Settings → SSH and GPG keys). Once set up, a "verified" badge will be shown next to your signed commits in the upstream repository's GUI.

----
$ gpg --armor --export <key-id>
----

==== WSL-specific configuration

The above configuration works fine when using Git exclusively in the WSL environment. But if you are committing from a Windows GUI client (eg. VS Code's built-in Git client, or GitHub Desktop), you will need some additional configuration so that you are prompted for your GPG key's passphrase via the Windows GUI.

The solution is to download and install https://www.gpg4win.org[GPG4Win], and configure Git in WSL to use GPG4Win's `gpg.exe` Windows binary, rather than the `gpg` binary installed in WSL.

In WSL, create a wrapper script for GPG4Win's `gpg.exe`:

----
$ sudo vim /usr/local/bin/gpg
----

Add the following contents:

----
#!/bin/bash

/mnt/c/Program\ Files\ \(x86\)/GnuPG/bin/gpg.exe "$@"
----

Make it executable:

----
$ sudo chmod +x /usr/local/bin/gpg
----

Configure Git to use the wrapper script instead of the default `gpg` binary:

----
$ git config --global gpg.program /usr/local/bin/gpg
----

Export your GPG key pair from WSL, and import the keys into GPG4Win:

----
$ gpg --armor --export-secret-keys YOUR_EMAIL > private.key
$ gpg --armor --export YOUR_EMAIL > public.key
----

Copy the files to somewhere on the Windows filesystem.

Open Kleopatra, an OpenPGP certificate and key management utility that is installed with GPG4Win. Go to *File -> Import Certificates*, and import both the `public.key` and `private.key` files you exported from WSL. The key should now be listed in Kleopatra, under *Certificates*.

Alternatively, you can import the keys via the command line:

----
cd C:\path\to\your\keys

# Import private key first (this usually imports the public key too)
"C:\Program Files (x86)\GnuPG\bin\gpg.exe" --import private.key

# Import public key (if needed)
"C:\Program Files (x86)\GnuPG\bin\gpg.exe" --import public.key
----

Verify the import:

----
# List secret keys
"C:\Program Files (x86)\GnuPG\bin\gpg.exe" --list-secret-keys

# List public keys
"C:\Program Files (x86)\GnuPG\bin\gpg.exe" --list-keys
----

[IMPORTANT]
======
Delete the original `public.key` and `private.key` files after importing them to GPG.
======

To test the configuration, make a commit from a Windows GUI Git client, and you should be prompted for your GPG key's passphrase via a Windows GUI dialog. Also test via WSL, using either of the below commands. You should get the same "pinentry" dialog, rather than the original terminal prompt, for your passphrase.

----
# Sign an arbitrary piece of text.
echo "test" | gpg --clearsign

# Create a signed commit (may be empty).
git commit --allow-empty -m "test signed commit"
----

[TIP]
======
Your passphrase is held in memory by the GPG agent. You need to restart the agent to clear the cached passphrase. For the native Linux agent you would use:

----
$ gpgconf --kill gpg-agent
----

But of course you're now using the Windows agent, so you need to issue the following command from Powershell or the regular Command Prompt:

----
taskkill /f /im gpg-agent.exe
----

On the next GPG command, it will take a few seconds for the agent to startup, and then you will be prompted for your passphrase again.
======

== Other GPG cheats

Get the GPG version:

----
$ gpg --version
----

Kill the GPG agent:

----
$ gpgconf --kill gpg-agent
----
