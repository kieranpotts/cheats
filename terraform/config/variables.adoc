= Variables

In Terraform, there are two main files involved in setting input variables: `variables.tf` and `terraform.tfvars`.

The `variables.tf` file is used to declare variables and set their default values. In contains `variable` blocks that define the name, description, type, and default value of each variable. This file is normally committed to version control, as it serves as documentation for the variables used in the Terraform configuration.

The terraform.tfvars file is used to assign values to the variables declared in `variables.tf`. This file is often excluded from version control, as it may contain sensitive data.

Variables are accessed from `*.tf` files via the `var.{name}` syntax. For example, if you have a variable named `vpc_cidr` declared in `variables.tf`, you can reference it in your infrastructure-as-code files via `var.vpc_cidr`.

In summary:

* Required variables are specified in `variables.tf`.
* The variables are assigned values in `terraform.tfvars`.
* The values are accessed in the Terraform configuration via `var.{name}`.

This separation makes it easier to maintain a strict variable interface, and easier to change implementations across environments.

It is RECOMMENDED to define variables for all values that are likely to change between environments, and between deployments to the same environment.

== variables.tf

The `variables.tf` file defines the structure and metadata of input variables. It contains:

* Variable names and types
* Descriptions
* Validation rules
* Constraint settings
* Default values (optional)

.variables.tf
[source]
----
variable "vpc_cidr" {
  description = "Value of the CIDR range for the VPC"
  type        = string
  default     = "10.0.0.0/16"
}

variable "vpc_name" {
  description = "Value of the name for the VPC"
  type        = string
  default     = "MyTestVPC"
}

variable "subnet_cidr" {
  description = "Value of the subnet cidr for the VPC"
  type        = string
  default     = "10.0.1.0/24"
}

variable "subnet_name" {
  description = "Value of the subnet name for the VPC"
  type        = string
  default     = "MyTestSubnet"
}

variable "igw_name" {
  description = "Value of the Internet Gateway for the VPC"
  type        = string
  default     = "MyTestIGW"
}

variable "ec2_ami" {
  description = "Value of the AMI ID for the EC2 instance"
  type        = string
  default     = "ami-03c6b308140d10488"
}

variable "ec2_name" {
  description = "Value fo the Name for the EC2 instance"
  type        = string
  default     = "MyTestEC2"
}
----

== terraform.tfvars

The `terraform.tfvars` file provides actual values for the variables defined in `variables.tf`. This file contains:

* Simple variable assignments
* Environment-specific settings
* Credential values

.terraform.tfvars
[source]
----
## VPC
vpc_cidr = "10.0.0.0/16"
vpc_name = "MyTestVPC"

## Public Subnet
subnet_cidr = "10.0.1.0/24"
subnet_name = "MyTestSubnet"

## Internet Gateway
igw_name = "MyTestIGW"

## EC2 Instance
ec2_ami = "ami-03c6b308140d10488"
ec2_name = "MyTestEC2"
----

== Default values

If a variable does not have a default value, and if no value is assigned to it in `terraform.tfvars`, Terraform will prompt for a value when the configuration is applied using `terraform apply`.

It is RECOMMENDED that all variables have default values. This allows the configuration to be used without requiring any input from the user. This also makes it easier to automate deployment to different environments (eg. to test and staging environments).

== Advanced variable usage

To replace this list of ports:

[source]
----
dynamic "ingress" {
  for_each = ["80", "443"]
  content {
    // ...
  }
}
----

Declare a variable, and assign a value:

[source]
----
variable "port_list" {
  description = "List of Ports to open for our WebServer"
  type        = list(any)
  default     = ["80", "443"]
}
----

Then we can use the variable in the `for_each` statement:

[source]
----
dynamic "ingress" {
  for_each = var.port_list
  content {
    // ...
  }
}
----

Variable values can also be maps, allowing for things like tags to be extracted to variables:

.main.tf
[source]
----
resource "aws_eip" "web" {
  instance = aws_instance.web.id
  tags     = var.tags
}
----

.variables.tf
[source]
----
variable "tags" {
  description = "Tags to Apply to Resources"
  type        = map(any)
  default = {
    Name = "EIP for WebServer"
    Environment = "Test"
    Owner = "K Potts"
  }
}
----

You can also extend maps using the `merge` function. This is useful for adding tags to resources without having to modify the original map.

.main.tf
[source]
----
resource "aws_eip" "web" {
  instance = aws_instance.web.id
  tags     = merge(var.tags, {
    Name = "EIP for WebServer in environment ${var.tags["Environment"]}"
  })
}
----

The above example also demonstrates how you can inject the values of variables into string values, using the `${var}` syntax. This is useful for creating dynamic values based on the values of other variables.

== Secrets

Variables that hold secrets should be marked as sensitive. This prevents Terraform from displaying the values in the console output. (It does not stop secrets leaking into the Terraform state file, however.)

[source]
----
variable "key_pair" {
  description = "SSH Key pair name to ingest into EC2"
  type        = string
  default     = "CanadaKey"
  sensitive   = true
}
----

== Validation

Validation blocks can be nested in variable block. Each validation block defines a condition that assigned values must meet. If the condition is not met, an error message is displayed and `terraform apply` will not run.

[source]
----
variable "password" {
  description = "Please Enter Password lenght of 10 characters!"
  type        = string
  sensitive   = true
  validation {
    condition     = length(var.password) == 10
    error_message = "Your Password must be 10 characted exactly!!!"
  }
}
----
