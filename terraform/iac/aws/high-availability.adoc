= High availability configurations

This section contains example Terraform configurations for high availability services.

We'll configure a HA web cluster into the default VPC in the `ca-central-1` region. The cluster will consist of:

* A security group for the web servers and ELB
* Launch configuration with auto AMI lookup
* An auto scaling group using 2 availability zones
* A classic load balancer in 2 availability zones
* The web servers will be updated via a green/blue deployment strategy

Here's some initial configuration to define the provider, region, and to create a reference to the default VPC (which already exists).

[source]
----
provider "aws" {
  region = "ca-central-1"
}

resource "aws_default_vpc" "default" {}
----

We need to get data on the AZs in this region.

[source]
----
data "aws_availability_zones" "working" {}
----

Next, we want to get the latest AMI for Amazon Linux.

[source]
----
data "aws_ami" "latest_amazon_linux" {
  owners      = ["137112412989"]
  most_recent = true
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}
----

Next, we need to create a security group, which will be used for the web servers and load balancer.

[source]
----
resource "aws_security_group" "web" {
  name   = "Web Security Group"
  vpc_id = aws_default_vpc.default.id
  
  dynamic "ingress" {
    for_each = ["80", "443"]
    content {
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
----

Next, we will define the launch configuration. This will be used to create the web servers in the auto scaling group. The launch configuration will use the latest Amazon Linux AMI, and will use a user data script to install and configure the web server.

[source]
----
resource "aws_launch_configuration" "web" {
  /* Note: we define only a prefix for the name. The suffix will be
  automatically generated by Terraform. */
  name_prefix     = "WebServer-Highly-Available-LC-"

  image_id        = data.aws_ami.latest_amazon_linux.id
  instance_type   = "t3.micro"
  
  security_groups = [aws_security_group.web.id]
  user_data       = file("user_data.sh")

  /* We want blue-green deployments, so this life-cycle 
  configuration is required. *.
  lifecycle {
    create_before_destroy = true
  }
}
----

.user_data.sh
[source]
----
#!/bin/bash
yum -y update
yum -y install httpd

myip=`curl http://169.254.169.254/latest/meta-data/local-ipv4`

cat <<EOF > /var/www/html/index.html
<html>
<body bgcolor="black">
<h2><font color="gold">Build by Power of <font color="red">Terraform</font></h2><br><p>
<font color="green">Server PrivateIP: <font color="aqua">$myip<br><br>
<font color="blue">
<b>Version 2.0</b>
</body>
</html>
EOF

service httpd start
chkconfig httpd on
----

Next, we configure an auto-scaling group.

[source]
----
resource "aws_autoscaling_group" "web" {
  /* The name of the ASG will be the same as the launch configuration 
  name, plus the ASG- prefix. */
  name                 = "ASG-${aws_launch_configuration.web.name}"

  launch_configuration = aws_launch_configuration.web.name
  
  /* Always run three servers. */
  min_size             = 3
  max_size             = 3
  min_elb_capacity     = 3
  
  /* Use the load balancer to do health checks. */
  health_check_type    = "ELB"
  
  /* (Defined below.) */
  vpc_zone_identifier  = [aws_default_subnet.default_az1.id, aws_default_subnet.default_az2.id]
  load_balancers       = [aws_elb.web.name]

  dynamic "tag" {
    for_each = {
      Name   = "WebServer in ASG"
      TAGKEY = "TAGVALUE"
    }
    content {
      key                 = tag.key
      value               = tag.value
      propagate_at_launch = true
    }
  }

  lifecycle {
    create_before_destroy = true
  }
}
----

Next, we configure a classic load balancer resource.

[source]
----
resource "aws_elb" "web" {
  name               = "WebServer-HighlyAvailable-ELB"

  /* Use the first and second AZs in the region. */
  availability_zones = [data.aws_availability_zones.working.names[0], data.aws_availability_zones.working.names[1]]

  security_groups    = [aws_security_group.web.id]
  
  listener {
    lb_port           = 80
    lb_protocol       = "http"
    instance_port     = 80
    instance_protocol = "http"
  }
  
  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 2
    timeout             = 3
    target              = "HTTP:80/"
    interval            = 10
  }
  
  tags = {
    Name  = "WebServer-HighlyAvailable-ELB"
  }
}
----

Finally, we need to create references to the default subnets in the two availability zones. These resources already exist - we're just "adopting" them into our Terraform configuration.

[source]
----
resource "aws_default_subnet" "default_az1" {
  availability_zone = data.aws_availability_zones.working.names[0]
}

resource "aws_default_subnet" "default_az2" {
  availability_zone = data.aws_availability_zones.working.names[1]
}
----

Finally, we need to output the load balancer DNS name, so we can access it via a web browser.

[source]
----
output "web_loadbalancer_url" {
  value = aws_elb.web.dns_name
}
----
